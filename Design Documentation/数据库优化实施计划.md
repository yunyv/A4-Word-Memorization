# 数据库优化实施计划

## 项目概述

本项目旨在优化单词学习应用的数据库存储结构，将原本存储在单一JSON字段中的单词数据拆分为多个关联表，提高查询效率和数据管理能力。

## 实施阶段

### 阶段一：准备工作 ✅

- [x] 分析当前爬取的数据结构和数据库存储方式
- [x] 设计优化的数据库表结构，将爬取的数据分表存储
- [x] 编写设计文档，说明新的数据库架构
- [x] 创建数据库关系图，直观展示表结构关系
- [x] 设计数据迁移脚本，确保数据完整性

### 阶段二：数据库结构更新

- [ ] 更新 Prisma Schema 文件
- [ ] 生成并应用数据库迁移
- [ ] 验证新表结构创建成功

### 阶段三：代码更新

- [ ] 修改爬虫逻辑，将数据同时存储到JSON和新表结构
- [ ] 更新API路由，优先从新表结构读取数据
- [ ] 添加数据类型定义，支持新的表结构

### 阶段四：数据迁移

- [ ] 执行数据迁移脚本，将现有JSON数据迁移到新表
- [ ] 验证迁移结果，确保数据完整性
- [ ] 处理迁移过程中出现的错误数据

### 阶段五：测试与优化

- [ ] 全面测试API功能，确保新旧数据结构兼容
- [ ] 性能测试，验证查询效率提升
- [ ] 根据测试结果优化索引和查询逻辑

### 阶段六：部署与监控

- [ ] 在生产环境部署更新
- [ ] 监控系统运行状态
- [ ] 根据监控结果进行进一步优化

## 详细实施步骤

### 步骤1：更新数据库结构

1. **备份当前数据库**
   ```bash
   mysqldump -u root -p a4recite > backup_$(date +%Y%m%d_%H%M%S).sql
   ```

2. **更新 Prisma Schema**
   - 将 `Design Documentation/新Prisma Schema.md` 中的内容复制到 `prisma/schema.prisma`
   - 确保所有表结构和关系定义正确

3. **生成迁移文件**
   ```bash
   npx prisma migrate dev --name add_word_details_tables
   ```

4. **更新 Prisma 客户端**
   ```bash
   npx prisma generate
   ```

### 步骤2：创建数据类型定义

创建 `src/types/word.ts` 文件，定义新的数据类型：

```typescript
export interface WordPronunciation {
  id: number;
  wordId: number;
  type: 'american' | 'british';
  phonetic: string;
  audioUrl?: string;
}

export interface WordDefinition {
  id: number;
  wordId: number;
  type: 'basic' | 'web' | 'authoritative' | 'bilingual' | 'english';
  partOfSpeech?: string;
  order: number;
  meaning?: string;
  chineseMeaning?: string;
  englishMeaning?: string;
  definitionNumber?: number;
  linkedWords?: string;
  examples?: DefinitionExample[];
  idioms?: DefinitionIdiom[];
}

export interface DefinitionExample {
  id: number;
  definitionId: number;
  order: number;
  english: string;
  chinese?: string;
}

export interface DefinitionIdiom {
  id: number;
  definitionId: number;
  order: number;
  title: string;
  meaning: string;
  examples?: IdiomExample[];
}

export interface IdiomExample {
  id: number;
  idiomId: number;
  order: number;
  english: string;
  chinese?: string;
}

export interface WordSentence {
  id: number;
  wordId: number;
  order: number;
  english: string;
  chinese?: string;
  audioUrl?: string;
  source?: string;
}

export interface WordForm {
  id: number;
  wordId: number;
  formType: string;
  formWord: string;
}
```

### 步骤3：更新爬虫逻辑

修改 `src/lib/dictionary.ts` 中的 `DictionaryScraper` 类，添加将数据保存到新表结构的方法：

```typescript
// 添加保存到新表结构的方法
async saveWordDataToTables(wordText: string, data: any): Promise<void> {
  const word = await db.word.upsert({
    where: { wordText: wordText.toLowerCase() },
    update: {
      pronunciation: data.pronunciation,
      definitionData: convertToPrismaJson(data),
      updatedAt: new Date()
    },
    create: {
      wordText: wordText.toLowerCase(),
      pronunciation: data.pronunciation,
      definitionData: convertToPrismaJson(data)
    }
  });

  // 保存发音数据
  if (data.pronunciationData) {
    await this.savePronunciationData(word.id, data.pronunciationData);
  }

  // 保存释义数据
  if (data.definitions) {
    await this.saveDefinitionData(word.id, data.definitions);
  }

  // 保存其他类型的数据...
}

private async savePronunciationData(wordId: number, pronunciationData: any): Promise<void> {
  // 实现保存发音数据的逻辑
}

private async saveDefinitionData(wordId: number, definitions: any): Promise<void> {
  // 实现保存释义数据的逻辑
}
```

### 步骤4：更新API路由

修改 `src/app/api/dictionary/route.ts`，优先从新表结构读取数据：

```typescript
// 添加从新表结构获取数据的方法
async function getWordFromTables(wordText: string): Promise<any> {
  const word = await db.word.findUnique({
    where: { wordText: wordText.toLowerCase() },
    include: {
      pronunciations: true,
      definitions: {
        include: {
          examples: true,
          idioms: {
            include: {
              examples: true
            }
          }
        }
      },
      sentences: true,
      wordForms: true
    }
  });

  if (!word) return null;

  // 将表结构数据转换为原有JSON格式
  return convertTablesToJson(word);
}

function convertTablesToJson(word: any): any {
  // 实现将表结构数据转换为JSON格式的逻辑
}
```

### 步骤5：执行数据迁移

1. **创建迁移脚本目录**
   ```bash
   mkdir -p scripts
   ```

2. **创建迁移脚本文件**
   - 将 `Design Documentation/数据迁移脚本.md` 中的脚本内容保存到 `scripts/migrate-word-data.ts`
   - 将验证脚本保存到 `scripts/validate-migration.ts`

3. **安装必要的依赖**
   ```bash
   npm install ts-node --save-dev
   ```

4. **执行数据迁移**
   ```bash
   npx ts-node scripts/migrate-word-data.ts
   ```

5. **验证迁移结果**
   ```bash
   npx ts-node scripts/validate-migration.ts
   ```

### 步骤6：测试与验证

1. **功能测试**
   - 测试单词查询API
   - 测试词书上传功能
   - 测试学习进度跟踪

2. **性能测试**
   - 对比新旧结构的查询时间
   - 测试大量数据查询的性能

3. **数据一致性测试**
   - 验证新旧表结构数据的一致性
   - 确保没有数据丢失或损坏

## 风险管理

### 主要风险

1. **数据丢失风险**
   - 缓解措施：完整备份、分步迁移、验证机制

2. **性能影响风险**
   - 缓解措施：性能测试、索引优化、渐进式切换

3. **兼容性问题**
   - 缓解措施：保留JSON字段、双重存储、全面测试

### 回滚计划

1. **数据库回滚**
   ```bash
   mysql -u root -p a4recite < backup_YYYYMMDD_HHMMSS.sql
   ```

2. **代码回滚**
   - 使用Git回滚到迁移前的版本
   - 恢复原有的Prisma Schema

## 成功标准

1. **功能完整性**
   - 所有现有功能正常工作
   - 新表结构数据查询正确

2. **性能提升**
   - 单词查询响应时间减少至少20%
   - 数据库查询效率提升

3. **数据完整性**
   - 迁移后数据与原数据100%一致
   - 没有数据丢失或损坏

## 后续优化

1. **逐步移除JSON字段**
   - 在确认新表结构稳定后，逐步移除对JSON字段的依赖
   - 最终清理JSON字段，释放存储空间

2. **进一步性能优化**
   - 根据实际使用情况调整索引策略
   - 考虑添加缓存层，进一步提升性能

3. **功能扩展**
   - 基于新表结构添加更多功能
   - 支持更复杂的查询和分析

## 时间计划

| 阶段 | 预计时间 | 开始时间 | 结束时间 |
|------|----------|----------|----------|
| 准备工作 | 已完成 | - | 已完成 |
| 数据库结构更新 | 0.5天 | 待定 | 待定 |
| 代码更新 | 1天 | 待定 | 待定 |
| 数据迁移 | 0.5天 | 待定 | 待定 |
| 测试与优化 | 1天 | 待定 | 待定 |
| 部署与监控 | 0.5天 | 待定 | 待定 |
| **总计** | **3.5天** | | |

## 负责人

- **数据库设计**：架构师
- **代码实现**：开发工程师
- **测试验证**：测试工程师
- **部署监控**：运维工程师

## 沟通计划

1. **日常沟通**
   - 每日站会同步进度
   - 遇到问题及时沟通解决

2. **里程碑汇报**
   - 每个阶段完成后进行汇报
   - 重要决策需要相关人员确认

3. **文档更新**
   - 及时更新项目文档
   - 记录实施过程中的经验和教训