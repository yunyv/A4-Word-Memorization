# 数据库优化设计文档

## 1. 当前问题分析

### 1.1 现有数据存储方式
目前项目中，爬取的单词数据以JSON格式存储在`Words`表的`definition_data`字段中。这种方式存在以下问题：

1. **查询效率低**：无法直接对JSON内部的数据进行高效查询和索引
2. **数据冗余**：每次查询都需要加载完整的JSON数据，即使只需要部分信息
3. **扩展性差**：添加新的数据字段需要修改JSON结构，不利于数据管理
4. **缓存效率低**：无法针对部分数据进行缓存，只能缓存整个JSON对象

### 1.2 爬取数据结构分析
根据`src/lib/dictionary.ts`文件分析，爬取的数据包含以下主要部分：

1. **音标和音频数据** (`PronunciationData`)
   - 美式音标和音频URL
   - 英式音标和音频URL

2. **释义数据** (多种类型)
   - 基本释义 (`basic`)
   - 网络释义 (`web`)
   - 权威英汉释义 (`AuthoritativeDefinition`)
   - 英汉释义 (`BilingualDefinition`)
   - 英英释义 (`EnglishDefinition`)

3. **例句数据** (`Sentence`)
   - 英文例句
   - 中文例句
   - 音频URL
   - 来源信息
   - 高亮单词

4. **词形变换数据**
   - 复数、过去式等词形变化

## 2. 优化设计方案

### 2.1 设计原则
1. **规范化存储**：将JSON数据拆分为多个关联表，提高查询效率
2. **保持兼容**：保留原有JSON字段作为备份，确保平滑过渡
3. **索引优化**：为常用查询字段添加索引
4. **灵活扩展**：设计支持未来添加新的数据类型

### 2.2 新表结构设计

#### 2.2.1 单词基本信息表 (Words)
保留原有表结构，但添加一些基本字段：

```prisma
model Word {
  id              Int      @id @default(autoincrement())
  wordText        String   @unique @map("word_text") @db.VarChar(100)
  
  // 基本信息字段
  pronunciation   String?  @map("pronunciation") @db.VarChar(200)
  
  // 保留原有JSON字段作为备份
  definitionData  Json?    @map("definition_data")
  
  // 时间戳
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @default(now()) @updatedAt @map("updated_at")

  // 关联关系
  pronunciations   WordPronunciation[]
  definitions      WordDefinition[]
  sentences        WordSentence[]
  wordForms        WordForm[]
  wordlistEntries  WordlistEntry[]
  userWordProgress UserWordProgress[]

  @@map("Words")
}
```

#### 2.2.2 单词发音表 (WordPronunciations)
存储单词的音标和音频信息：

```prisma
model WordPronunciation {
  id        Int      @id @default(autoincrement())
  wordId    Int      @map("word_id")
  type      String   @db.VarChar(20) // 'american' | 'british'
  phonetic  String   @db.VarChar(100)
  audioUrl  String?  @map("audio_url") @db.Text
  
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  // 关联关系
  word Word @relation(fields: [wordId], references: [id], onDelete: Cascade)

  @@unique([wordId, type])
  @@map("WordPronunciations")
}
```

#### 2.2.3 单词释义表 (WordDefinitions)
存储各种类型的释义：

```prisma
model WordDefinition {
  id          Int      @id @default(autoincrement())
  wordId      Int      @map("word_id")
  type        String   @db.VarChar(30) // 'basic' | 'web' | 'authoritative' | 'bilingual' | 'english'
  partOfSpeech String? @map("part_of_speech") @db.VarChar(50)
  order       Int      @default(0) // 释义顺序
  
  // 基本释义和网络释义使用
  meaning     String?  @db.Text
  
  // 权威英汉释义使用
  chineseMeaning  String? @map("chinese_meaning") @db.Text
  englishMeaning  String? @map("english_meaning") @db.Text
  definitionNumber Int?   @map("definition_number")
  
  // 英英释义使用
  linkedWords String? @map("linked_words") @db.Text // JSON array of linked words
  
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  // 关联关系
  word       Word       @relation(fields: [wordId], references: [id], onDelete: Cascade)
  examples   DefinitionExample[]
  idioms     DefinitionIdiom[]

  @@index([wordId, type])
  @@map("WordDefinitions")
}
```

#### 2.2.4 释义例句表 (DefinitionExamples)
存储释义中的例句：

```prisma
model DefinitionExample {
  id            Int      @id @default(autoincrement())
  definitionId  Int      @map("definition_id")
  order         Int      @default(0) // 例句顺序
  english       String   @db.Text
  chinese       String?  @db.Text
  
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  // 关联关系
  definition WordDefinition @relation(fields: [definitionId], references: [id], onDelete: Cascade)

  @@index([definitionId])
  @@map("DefinitionExamples")
}
```

#### 2.2.5 释义习语表 (DefinitionIdioms)
存储释义中的习语：

```prisma
model DefinitionIdiom {
  id            Int      @id @default(autoincrement())
  definitionId  Int      @map("definition_id")
  order         Int      @default(0) // 习语顺序
  title         String   @db.VarChar(200)
  meaning       String   @db.Text
  
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  // 关联关系
  definition WordDefinition @relation(fields: [definitionId], references: [id], onDelete: Cascade)
  examples   IdiomExample[]

  @@index([definitionId])
  @@map("DefinitionIdioms")
}
```

#### 2.2.6 习语例句表 (IdiomExamples)
存储习语中的例句：

```prisma
model IdiomExample {
  id         Int      @id @default(autoincrement())
  idiomId    Int      @map("idiom_id")
  order      Int      @default(0) // 例句顺序
  english    String   @db.Text
  chinese    String?  @db.Text
  
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  // 关联关系
  idiom DefinitionIdiom @relation(fields: [idiomId], references: [id], onDelete: Cascade)

  @@index([idiomId])
  @@map("IdiomExamples")
}
```

#### 2.2.7 单词例句表 (WordSentences)
存储独立的例句（非释义中的例句）：

```prisma
model WordSentence {
  id         Int      @id @default(autoincrement())
  wordId     Int      @map("word_id")
  order      Int      @default(0) // 例句顺序
  english    String   @db.Text
  chinese    String?  @db.Text
  audioUrl   String?  @map("audio_url") @db.Text
  source     String?  @db.VarChar(200) // 例句来源
  
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  // 关联关系
  word Word @relation(fields: [wordId], references: [id], onDelete: Cascade)

  @@index([wordId])
  @@map("WordSentences")
}
```

#### 2.2.8 词形变换表 (WordForms)
存储单词的各种形态变化：

```prisma
model WordForm {
  id        Int      @id @default(autoincrement())
  wordId    Int      @map("word_id")
  formType  String   @map("form_type") @db.VarChar(50) // 'plural', 'past_tense', etc.
  formWord  String   @map("form_word") @db.VarChar(100)
  
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  // 关联关系
  word Word @relation(fields: [wordId], references: [id], onDelete: Cascade)

  @@unique([wordId, formType])
  @@map("WordForms")
}
```

### 2.3 数据查询优化

#### 2.3.1 常用查询模式
1. **查询单词基本信息**：从Words表获取基本信息和音标
2. **查询单词释义**：根据类型从WordDefinitions表获取释义
3. **查询单词例句**：从WordSentences表获取例句
4. **查询单词发音**：从WordPronunciations表获取音标和音频

#### 2.3.2 索引策略
1. **Words表**：wordText(唯一索引)
2. **WordPronunciations表**：wordId+type(复合索引)
3. **WordDefinitions表**：wordId+type(复合索引)
4. **WordSentences表**：wordId(索引)
5. **WordForms表**：wordId+formType(复合索引)

## 3. 数据迁移方案

### 3.1 迁移步骤
1. 创建新表结构
2. 编写数据迁移脚本，将现有JSON数据解析并插入到新表
3. 更新API代码，从新表结构中读取数据
4. 保留原有JSON字段作为备份
5. 验证数据完整性

### 3.2 兼容性策略
1. **渐进式迁移**：先保留原有JSON字段，确保系统正常运行
2. **双重存储**：新数据同时存储到JSON和新表结构中
3. **逐步切换**：验证新表结构稳定后，逐步切换到新结构

## 4. 性能优化预期

### 4.1 查询性能提升
1. **精准查询**：只需查询特定字段，减少数据传输量
2. **索引优化**：常用查询字段添加索引，提高查询速度
3. **缓存效率**：可以针对不同类型的数据进行缓存

### 4.2 存储空间优化
1. **减少冗余**：避免重复存储相同的数据结构
2. **压缩存储**：文本数据可以使用更高效的存储方式

### 4.3 扩展性提升
1. **灵活扩展**：添加新字段只需添加新表或新列，不影响现有结构
2. **数据关联**：可以轻松添加新的关联表，支持更复杂的数据结构

## 5. 实施计划

1. **第一阶段**：创建新表结构和数据迁移脚本
2. **第二阶段**：修改爬虫代码，同时写入JSON和新表结构
3. **第三阶段**：修改API代码，优先从新表结构读取数据
4. **第四阶段**：验证数据一致性，优化查询性能
5. **第五阶段**：逐步移除对JSON字段的依赖

## 6. 风险评估

1. **数据一致性**：需要确保新旧数据结构之间的数据一致性
2. **迁移复杂性**：JSON数据解析可能存在格式兼容性问题
3. **性能影响**：初期可能因为同时写入新旧结构而影响性能
4. **回滚方案**：需要准备回滚方案，以防新结构出现问题

## 7. 监控指标

1. **查询性能**：监控API响应时间变化
2. **存储空间**：监控数据库存储空间使用情况
3. **数据完整性**：定期检查新旧数据结构的一致性
4. **错误率**：监控数据读写错误率