# 数据迁移脚本设计

## 概述

本文档描述了将现有JSON格式的单词数据迁移到新的表结构中的脚本设计。迁移过程需要确保数据完整性，并提供回滚机制。

## 迁移策略

### 1. 渐进式迁移
- 保留原有JSON字段作为备份
- 新数据同时写入JSON和新表结构
- 逐步切换到新结构读取数据

### 2. 数据完整性保证
- 迁移前后数据校验
- 错误处理和日志记录
- 支持断点续传

## 迁移脚本结构

### 1. 主迁移脚本 (migrate-word-data.ts)

```typescript
// 脚本路径: scripts/migrate-word-data.ts
import { PrismaClient } from '@prisma/client';
import { DictionaryResult } from '@/lib/dictionary';

const prisma = new PrismaClient();

interface MigrationStats {
  totalWords: number;
  migratedWords: number;
  skippedWords: number;
  errors: Array<{ word: string; error: string }>;
}

async function migrateWordData(): Promise<MigrationStats> {
  const stats: MigrationStats = {
    totalWords: 0,
    migratedWords: 0,
    skippedWords: 0,
    errors: []
  };

  try {
    // 1. 获取所有有JSON数据的单词
    const words = await prisma.word.findMany({
      where: {
        definitionData: {
          not: null
        }
      }
    });

    stats.totalWords = words.length;
    console.log(`找到 ${words.length} 个需要迁移的单词`);

    // 2. 逐个处理单词
    for (const word of words) {
      try {
        await migrateSingleWord(word);
        stats.migratedWords++;
        console.log(`✅ 成功迁移单词: ${word.wordText}`);
      } catch (error) {
        stats.errors.push({
          word: word.wordText,
          error: error instanceof Error ? error.message : '未知错误'
        });
        console.error(`❌ 迁移单词失败: ${word.wordText}`, error);
      }
    }

    // 3. 输出迁移统计
    console.log('\n=== 迁移完成 ===');
    console.log(`总单词数: ${stats.totalWords}`);
    console.log(`成功迁移: ${stats.migratedWords}`);
    console.log(`跳过单词: ${stats.skippedWords}`);
    console.log(`错误数量: ${stats.errors.length}`);

    if (stats.errors.length > 0) {
      console.log('\n错误详情:');
      stats.errors.forEach(err => console.log(`- ${err.word}: ${err.error}`));
    }

    return stats;
  } catch (error) {
    console.error('迁移过程中发生严重错误:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

async function migrateSingleWord(word: any) {
  const definitionData = word.definitionData as any;
  
  if (!definitionData) {
    return; // 跳过没有数据的单词
  }

  // 使用事务确保数据一致性
  await prisma.$transaction(async (tx) => {
    // 1. 更新基本发音信息
    if (definitionData.pronunciation) {
      await tx.word.update({
        where: { id: word.id },
        data: {
          pronunciation: definitionData.pronunciation
        }
      });
    }

    // 2. 迁移发音数据
    if (definitionData.pronunciationData) {
      await migratePronunciationData(tx, word.id, definitionData.pronunciationData);
    }

    // 3. 迁移释义数据
    if (definitionData.definitions) {
      await migrateDefinitionData(tx, word.id, definitionData.definitions);
    }

    // 4. 迁移权威英汉释义
    if (definitionData.authoritativeDefinitions) {
      await migrateAuthoritativeDefinitions(tx, word.id, definitionData.authoritativeDefinitions);
    }

    // 5. 迁移英汉释义
    if (definitionData.bilingualDefinitions) {
      await migrateBilingualDefinitions(tx, word.id, definitionData.bilingualDefinitions);
    }

    // 6. 迁移英英释义
    if (definitionData.englishDefinitions) {
      await migrateEnglishDefinitions(tx, word.id, definitionData.englishDefinitions);
    }

    // 7. 迁移例句数据
    if (definitionData.sentences && definitionData.sentences.length > 0) {
      await migrateSentenceData(tx, word.id, definitionData.sentences);
    }

    // 8. 迁移词形变化
    if (definitionData.wordForms && definitionData.wordForms.length > 0) {
      await migrateWordForms(tx, word.id, definitionData.wordForms);
    }
  });
}

async function migratePronunciationData(tx: any, wordId: number, pronunciationData: any) {
  // 美式发音
  if (pronunciationData.american) {
    await tx.wordPronunciation.upsert({
      where: {
        wordId_type: {
          wordId,
          type: 'american'
        }
      },
      update: {
        phonetic: pronunciationData.american.phonetic,
        audioUrl: pronunciationData.american.audioUrl
      },
      create: {
        wordId,
        type: 'american',
        phonetic: pronunciationData.american.phonetic,
        audioUrl: pronunciationData.american.audioUrl
      }
    });
  }

  // 英式发音
  if (pronunciationData.british) {
    await tx.wordPronunciation.upsert({
      where: {
        wordId_type: {
          wordId,
          type: 'british'
        }
      },
      update: {
        phonetic: pronunciationData.british.phonetic,
        audioUrl: pronunciationData.british.audioUrl
      },
      create: {
        wordId,
        type: 'british',
        phonetic: pronunciationData.british.phonetic,
        audioUrl: pronunciationData.british.audioUrl
      }
    });
  }
}

async function migrateDefinitionData(tx: any, wordId: number, definitions: any) {
  // 基本释义
  if (definitions.basic && definitions.basic.length > 0) {
    for (let i = 0; i < definitions.basic.length; i++) {
      const def = definitions.basic[i];
      await tx.wordDefinition.create({
        data: {
          wordId,
          type: 'basic',
          partOfSpeech: def.partOfSpeech,
          order: i,
          meaning: def.meaning
        }
      });
    }
  }

  // 网络释义
  if (definitions.web && definitions.web.length > 0) {
    for (let i = 0; i < definitions.web.length; i++) {
      const def = definitions.web[i];
      await tx.wordDefinition.create({
        data: {
          wordId,
          type: 'web',
          order: i,
          meaning: def.meaning
        }
      });
    }
  }
}

async function migrateAuthoritativeDefinitions(tx: any, wordId: number, authoritativeDefinitions: any[]) {
  for (const authDef of authoritativeDefinitions) {
    // 创建主释义记录
    const definition = await tx.wordDefinition.create({
      data: {
        wordId,
        type: 'authoritative',
        partOfSpeech: authDef.partOfSpeech,
        order: 0 // 可以根据需要调整排序
      }
    });

    // 创建释义条目
    for (const defItem of authDef.definitions) {
      await tx.definitionExample.create({
        data: {
          definitionId: definition.id,
          order: defItem.number,
          english: defItem.englishMeaning || '',
          chinese: defItem.chineseMeaning || ''
        }
      });

      // 如果有例句，创建例句记录
      if (defItem.examples && defItem.examples.length > 0) {
        for (const example of defItem.examples) {
          await tx.definitionExample.create({
            data: {
              definitionId: definition.id,
              order: defItem.number,
              english: example.english,
              chinese: example.chinese
            }
          });
        }
      }
    }

    // 处理习语
    if (authDef.idioms && authDef.idioms.length > 0) {
      for (const idiom of authDef.idioms) {
        const idiomRecord = await tx.definitionIdiom.create({
          data: {
            definitionId: definition.id,
            order: idiom.number,
            title: idiom.title,
            meaning: idiom.meaning
          }
        });

        // 创建习语例句
        if (idiom.examples && idiom.examples.length > 0) {
          for (const example of idiom.examples) {
            await tx.idiomExample.create({
              data: {
                idiomId: idiomRecord.id,
                order: 0,
                english: example.english,
                chinese: example.chinese
              }
            });
          }
        }
      }
    }
  }
}

async function migrateBilingualDefinitions(tx: any, wordId: number, bilingualDefinitions: any[]) {
  for (const bilDef of bilingualDefinitions) {
    await tx.wordDefinition.create({
      data: {
        wordId,
        type: 'bilingual',
        partOfSpeech: bilDef.partOfSpeech,
        order: 0
      }
    });

    // 创建释义条目
    for (const defItem of bilDef.definitions) {
      await tx.definitionExample.create({
        data: {
          definitionId: wordId, // 这里需要调整，可能需要先获取刚创建的definition ID
          order: defItem.number,
          english: '',
          chinese: defItem.meaning
        }
      });
    }
  }
}

async function migrateEnglishDefinitions(tx: any, wordId: number, englishDefinitions: any[]) {
  for (const engDef of englishDefinitions) {
    const definition = await tx.wordDefinition.create({
      data: {
        wordId,
        type: 'english',
        partOfSpeech: engDef.partOfSpeech,
        order: 0
      }
    });

    // 创建释义条目
    for (const defItem of engDef.definitions) {
      await tx.wordDefinition.create({
        data: {
          wordId,
          type: 'english',
          partOfSpeech: engDef.partOfSpeech,
          order: defItem.number,
          meaning: defItem.meaning,
          linkedWords: defItem.linkedWords ? JSON.stringify(defItem.linkedWords) : null
        }
      });
    }
  }
}

async function migrateSentenceData(tx: any, wordId: number, sentences: any[]) {
  for (const sentence of sentences) {
    await tx.wordSentence.create({
      data: {
        wordId,
        order: sentence.number,
        english: sentence.english,
        chinese: sentence.chinese,
        audioUrl: sentence.audioUrl,
        source: sentence.source
      }
    });
  }
}

async function migrateWordForms(tx: any, wordId: number, wordForms: any[]) {
  for (const wordForm of wordForms) {
    await tx.wordForm.upsert({
      where: {
        wordId_formType: {
          wordId,
          formType: wordForm.form
        }
      },
      update: {
        formWord: wordForm.word
      },
      create: {
        wordId,
        formType: wordForm.form,
        formWord: wordForm.word
      }
    });
  }
}

// 执行迁移
if (require.main === module) {
  migrateWordData()
    .then(() => {
      console.log('迁移完成');
      process.exit(0);
    })
    .catch((error) => {
      console.error('迁移失败:', error);
      process.exit(1);
    });
}

export { migrateWordData, migrateSingleWord };
```

### 2. 数据验证脚本 (validate-migration.ts)

```typescript
// 脚本路径: scripts/validate-migration.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

interface ValidationResult {
  totalWords: number;
  wordsWithJson: number;
  wordsWithPronunciations: number;
  wordsWithDefinitions: number;
  wordsWithSentences: number;
  wordsWithForms: number;
  inconsistencies: Array<{
    word: string;
    issue: string;
  }>;
}

async function validateMigration(): Promise<ValidationResult> {
  const result: ValidationResult = {
    totalWords: 0,
    wordsWithJson: 0,
    wordsWithPronunciations: 0,
    wordsWithDefinitions: 0,
    wordsWithSentences: 0,
    wordsWithForms: 0,
    inconsistencies: []
  };

  try {
    // 获取所有单词
    const words = await prisma.word.findMany();
    result.totalWords = words.length;

    for (const word of words) {
      // 检查JSON数据
      if (word.definitionData) {
        result.wordsWithJson++;
      }

      // 检查发音数据
      const pronunciations = await prisma.wordPronunciation.count({
        where: { wordId: word.id }
      });
      if (pronunciations > 0) {
        result.wordsWithPronunciations++;
      }

      // 检查释义数据
      const definitions = await prisma.wordDefinition.count({
        where: { wordId: word.id }
      });
      if (definitions > 0) {
        result.wordsWithDefinitions++;
      }

      // 检查例句数据
      const sentences = await prisma.wordSentence.count({
        where: { wordId: word.id }
      });
      if (sentences > 0) {
        result.wordsWithSentences++;
      }

      // 检查词形数据
      const forms = await prisma.wordForm.count({
        where: { wordId: word.id }
      });
      if (forms > 0) {
        result.wordsWithForms++;
      }

      // 检查数据一致性
      if (word.definitionData && !pronunciations && !definitions && !sentences && !forms) {
        result.inconsistencies.push({
          word: word.wordText,
          issue: '有JSON数据但没有迁移到新表结构'
        });
      }
    }

    // 输出验证结果
    console.log('=== 数据验证结果 ===');
    console.log(`总单词数: ${result.totalWords}`);
    console.log(`有JSON数据的单词: ${result.wordsWithJson}`);
    console.log(`有发音数据的单词: ${result.wordsWithPronunciations}`);
    console.log(`有释义数据的单词: ${result.wordsWithDefinitions}`);
    console.log(`有例句数据的单词: ${result.wordsWithSentences}`);
    console.log(`有词形数据的单词: ${result.wordsWithForms}`);
    console.log(`数据不一致数量: ${result.inconsistencies.length}`);

    if (result.inconsistencies.length > 0) {
      console.log('\n不一致详情:');
      result.inconsistencies.forEach(inc => console.log(`- ${inc.word}: ${inc.issue}`));
    }

    return result;
  } catch (error) {
    console.error('验证过程中发生错误:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

// 执行验证
if (require.main === module) {
  validateMigration()
    .then(() => {
      console.log('验证完成');
      process.exit(0);
    })
    .catch((error) => {
      console.error('验证失败:', error);
      process.exit(1);
    });
}

export { validateMigration };
```

## 执行步骤

1. **备份数据库**
   ```bash
   mysqldump -u root -p a4recite > backup_$(date +%Y%m%d_%H%M%S).sql
   ```

2. **更新数据库结构**
   ```bash
   npx prisma migrate dev --name add_word_details_tables
   npx prisma generate
   ```

3. **执行数据迁移**
   ```bash
   npx ts-node scripts/migrate-word-data.ts
   ```

4. **验证迁移结果**
   ```bash
   npx ts-node scripts/validate-migration.ts
   ```

5. **处理错误数据**
   - 根据验证结果修复错误数据
   - 重新运行迁移脚本（支持增量迁移）

## 注意事项

1. **性能考虑**：大量数据迁移可能需要较长时间，建议在低峰期执行
2. **错误处理**：脚本已包含错误处理，但建议监控执行过程
3. **回滚方案**：保留数据库备份，必要时可以回滚
4. **测试环境**：建议先在测试环境中执行迁移，验证无误后再在生产环境执行

## 后续优化

1. **定期清理**：迁移完成后可以考虑清理JSON字段（需要谨慎）
2. **性能监控**：监控新表结构的查询性能
3. **索引优化**：根据实际查询模式调整索引策略